11/3/2023

1. Static (tĩnh):
 - Sử dụng để khai báo các thuộc tính và phương thức của lớp (không trực thuộc đối tượng);
 - Phương thức static chỉ có thể gọi các phương thức static khác.
 - Truy xuất biến static ( ko thể dùng this và super)
 - Có thể khởi tạo các dữ liệu static thông qua khối khởi tạo static.

2. Public : tất cả các lớp, đối tượng đều truy cập đc.
3. Private: thuộc tính và phương thức được tạo từ private chỉ có lớp đó truy cập, còn lại đều ko truy cập đc
4. Protected : có thể truy cập đc bởi tất cả các lớp (cùng package), lớp con (trong, ngoài package). Không thể sử dụng tham chiếu
5. Default : phạm vi truy cập chỉ nằm trong gói package.

Các phương thức được khai báo public trong một lớp cha cũng phải là public trong tất cả lớp phụ.

Các phương thức được khai báo protected trong một lớp cha phải hoặc là protected hoặc public trong các lớp phụ; chúng không thể là private.

Các phương thức được khai báo mà không có điều khiển truy cập (không sử dụng modifier nào) có thể được khai báo private trong các lớp phụ.

Các phương thức được khai báo private không được kế thừa, do đó không có qui tắc nào cho chúng.

6. Package (gói) : 

Java package được sử dụng để phân loại các lớp và các interface để mà chúng có thể được duy trì dễ dàng hơn.

Java package cung cấp bảo vệ truy cập.

Java package xóa bỏ các xung đột về đặt tên.

7. Extends : khai báo kế thừa
8. instanceof : toán tử kiểm tra kiểu đối tượng trả về kiểu boolean.
9. final : từ khóa áp dụng cho lớp ( ngăn ngừa kế thừa và ghi đè phương thức)


 + Import : lớp và đối tượng của package khác truy cập tới package hiện tại.
  - tenpackage.* : truy cập tất cả.
  - tenpackage.tenlop: truy cập đến lớp có tên tenlop.
10. 
	Cài đè (overriding) : cùng tên cùng kiểu cùng tham số
	Nạp chồng (overloading) : cùng tên ( khác kiểu hoặc tham số)

11. Kế thừa, đa hình: 

Lớp con chuyên biệt hóa lớp cha của nó.

Lớp con thừa kế tất cả các biến thực thể và phương thức public của lớp cha, nhưng không thừa kế các biến thực thể và phương thức private của lớp cha.

Có thể cài đè các phương thức được thừa kế; không thể cài đè các biến thực thể được thừa kế (tuy có thể gán trị lại tại lớp con, nhưng đây là hai việc khác nhau)

Để gọi phiên bản phương thức của lớp cha từ trong lớp con, sử dụng từ khóa super làm tham chiếu tới lớp cha.

12. Từ khóa This: 
	+ Ánh xạ đối tượng khi cần sử dụng.
	+ Gọi lại giá trị biến trong hàm tạo.

	vd: public class Person {
		public String name;
		public int age;
		public double height;	
		public Person(String name){
			this.name = name;
		}
		public Person(String name, int age){
			this(name);
			this.age = age;
		}
		public Person(String name, int age, double height){
			this(name, age);
			this.height = height;
		}
	}

14/3/2023

1. Abstract class: 
	+ Không thể tạo đối tượng của lớp abstract.
	+ Lớp chứa abstract method bắt buộc phải là abstract class.
	+ subclass abstract kế thừa superclass abstract => thực hiện toàn bộ abstract method.
	+ if (class or method is abstract) else (no final).
	+ Abstract Method: chỉ có phần khai báo, không có phần thân.
Cú pháp:
	+ Class: [Access Modifier] abstract class TenLop (){}
	+ Method: [Access Modifier] abstract [method] tenPhuongThuc (){}

2. Interface: 
	+ Tương tự như class (chỉ chứa constanst và abstract method), quy định các hành vi chung các lớp triển khai nó.
	+ Có thể kế thừa Interface khác.

Cú pháp: 
	
	+ Khai báo: [modifier] interface ITen {};
			[modifier] interface ITen1 {};

	+ Sử dụng (1 lớp kế thừa 1 hoặc nhiều interface): [modifier] class TenLop implement ITen, Iten1 () {}
	

16/3/2023

1. Stack:
	+ push(): thêm 1 phần tử cần lưu giữ vào ngăn xếp.
	+ pop(): xóa một phần tử từ ngăn xếp.
	+ peek(): lấy phần tử đầu tiên từ ngăn xếp mà không xóa phần tử này.
	+ isFull(): ktra ngăn xếp đầy hay không.
	+ isEmpty(): ktra ngăn xếp trống hay không.

20/3/2023

1. Sets : lưu trữ một nhóm các phần tử không có phần tử nào trùng nhau.

2. Lists: lưu trữ một tập các phần tử có thứ tự.

3. Stacks: lưu trữ tập các đối tượng được xử lý theo dạng last-in, first-out.

4. Queues: lưu trữ tập các đối tượng được xử lý theo dạng first-in, first-out.

5. PriorityQueues: lưu trữ tập các đối tượng được xử lý theo thứ tự ưu tiên của chúng. 


















